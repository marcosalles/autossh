#!/usr/local/bin/bash

# Loads params
while getopts :hec:m:d:u: opt; do
	NUMBER_REGEX='^[0-9]+$'
	case $opt in
		h)
			showHelp="on";
			break;;
		e)
			editMode="on";
			break;;
		c)
			if [[ $OPTARG =~ $NUMBER_REGEX ]]; then
				cols=$OPTARG;
			fi;;
		m)
			if [[ $OPTARG =~ $NUMBER_REGEX ]]; then
				machine=$OPTARG;
			fi;;
		d)
			downloadPath="$OPTARG";;
		u)
			uploadPath="$OPTARG";;
		:)
			echo "Option -$OPTARG requires an argument.";;
	esac
done

# Loads file params
if ! [ "$showHelp" = "on" ] && ! [ "$editMode" = "on" ]; then
	declare -a fileNames
	if [ $# -ge $OPTIND ]; then
		args=( $@ )
		for i in `seq $((OPTIND-1)) $((${#args[@]}-1))`; do
			fileNames=(${fileNames[@]} ${args[$i]})
		done
		unset args
	fi
fi

# Sets defaults
alignCols=${cols:-30}
REMOTE_HOSTS_LIST=${REMOTE_HOSTS_LIST:-~/ssh_hosts_list}

# Declares machine info maps
declare -A availableSystems
declare -A availableSystemHosts

# Loads remote hosts to maps
source $REMOTE_HOSTS_LIST

# Stores number of available machines
machineCount=${#availableSystems[@]}

# Sorts machines alphabetically by name
sortKeys() {
	for id in "${!availableSystems[@]}"; do
		echo $id;
	done | sort -r > ~/.keys.tmp
	entry=`tail -n -1 ~/.keys.tmp`
	i=1
	while [ ! "$entry" = "" ]; do
		printf -v entry "%-"$alignCols"s(%s)" $entry ${availableSystemHosts[$entry]}
		sortedKeys[$i]="$entry"
		i=$((i + 1))
		sed -ie '$d' ~/.keys.tmp
		entry=`tail -n -1 ~/.keys.tmp`
	done
	rm ~/.keys.tmp
}

# Shows usage / help text
showUsage() {
	scriptName=`basename "$0"`
	echo "Usage:"
	echo "  $scriptName [option:argument] [files]"
	echo
	echo "Options:"
	echo "  -h       Shows this help text and exits."
	echo
	echo "  -e       Edits current REMOTE_HOSTS_LIST file using default \$EDITOR or vim."
	echo "           If the file is missing, creates a default with sample values."
	echo
	echo "  -m n     n: machine number. Skips the machine listing and uses the"
	echo "           machine attached to that number, if valid. Ignores non-integers."
	echo
	echo "  -c n     n: machine name offset size. Number of columns the machine"
	echo "           name will use, with blanks on the right. Ignores non-integers."
	echo "           Default: 30."
	echo
	echo "  -u f     f: file path. Path where uploaded files will be saved remotely."
	echo
	echo "  -d f     f: file path. Path where downloaded files will be saved locally."
	echo
	echo "  files    Extra params that will be considered paths for upload or a single"
	echo "           path for download. Wildcards can be used for downloading, but as of"
	echo "           now it might bug if it matches anything locally."
	echo
	if [ $machineCount -eq 0 ]; then
		echo
		echo "You have no machines registered. To register a machine, create a"
		echo "REMOTE_HOSTS_LIST file, export its path to the REMOTE_HOSTS_LIST variable"
		echo "and follow the pattern, one for each entry:"
		echo "  name=\"Machine-name-no-spaces-or-special-characters\""
		echo "  availableSystems[\$name]=/path/to/your/private/key"
		echo "  availableSystemHosts[\$name]=user@host.address"
	fi
}

# Selects a machine to connect to
selectMachine() {
	select selectedMachine in "${sortedKeys[@]}" Exit
	do
		case $selectedMachine in
			Exit)
			  echo 0;
				break;;
			*)
				if [ $REPLY -gt ${#sortedKeys[@]} ] || [ $REPLY -lt 1 ]; then
					shift;
				else
					echo $REPLY;
					break;
				fi
		esac
	done
}

# Loads machine params
getMachineParams() {
	for i in "${!sortedKeys[@]}"; do
		if [ $i -eq $1 ]; then
			system=`echo ${sortedKeys[$i]} | cut -d" " -f1`
			systemKey=${availableSystems[$system]}
			systemHost=${availableSystemHosts[$system]}
			break
		fi
	done
}

# Connects to machine using SSH
connectToMachine() {
	echo "Connecting to $system.."
	ssh -i $systemKey $systemHost
}

# Downloads files from machine using SCP
downloadFromMachine() {
	if ! [ ${#fileNames[@]} -eq 1 ]; then
		echo "You need to specify a folder or file to download."
	else
		echo "Downloading files from $system.."
		scp -i $systemKey $systemHost:"${fileNames}" "$downloadPath"
	fi
}

# Uploads files to machine using SCP
uploadToMachine() {
	if [ ${#fileNames[@]} -eq 0 ]; then
		echo "You need to specify folders or files to upload."
	else
		echo "Uploading files to $system.."
		scp -i $systemKey "${fileNames[@]}" $systemHost:"$uploadPath"
	fi
}

# Creates a sample hosts file
createSampleHost() {
	if ! [ -f $REMOTE_HOSTS_LIST ]; then
		echo "#!/bin/bash" >> $REMOTE_HOSTS_LIST
		echo >> $REMOTE_HOSTS_LIST
		echo "# MACHINES LIST" >> $REMOTE_HOSTS_LIST
		echo >> $REMOTE_HOSTS_LIST
		echo "name=\"Machine-name-no-spaces-or-special-characters\"" >> $REMOTE_HOSTS_LIST
		echo "availableSystems[\$name]=/path/to/your/private/key" >> $REMOTE_HOSTS_LIST
		echo "availableSystemHosts[\$name]=user@host.address" >> $REMOTE_HOSTS_LIST
		echo >> $REMOTE_HOSTS_LIST
		echo "unset name" >> $REMOTE_HOSTS_LIST
		echo "# END MACHINES LIST" >> $REMOTE_HOSTS_LIST
		echo >> $REMOTE_HOSTS_LIST
	fi
}

# Starts the script
start() {
	if [ "$editMode" = "on" ]; then
		createSampleHost
		${EDITOR:-vim} $REMOTE_HOSTS_LIST
		exit 0
	fi

	if [ $machineCount -eq 0 ] || [ "$showHelp" = "on" ]; then
		showUsage
		exit 0
	fi

	declare -a sortedKeys; sortKeys

	if [ -z ${machine+x} ]; then
		machine=$(selectMachine)
	fi

	if [ $machine -lt 0 ] || [ $machine -gt $machineCount ]; then
		echo "You picked an invalid machine."
		machine=$(selectMachine)
	fi

	if [ $machine -eq 0 ]; then
		exit 1
	fi

	getMachineParams $machine

	if ! [ -z "${downloadPath+x}" ]; then
		downloadFromMachine
	elif ! [ -z "${uploadPath+x}" ]; then
		uploadToMachine
	else
		connectToMachine
	fi
}

start
